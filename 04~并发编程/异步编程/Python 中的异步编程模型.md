## Python 中的异步编程模型

Python 支持多种实现异步和并发的方式，主要包括：多线程、多进程和协程。每种方式适合不同的应用场景。

### 2.1 多线程（threading）

#### 原理

- 线程是操作系统能够进行运算调度的最小单位。
- Python 的 `threading` 模块可以让你在同一个进程中并发运行多个线程。
- 适合 I/O 密集型任务（如网络请求、文件读写），但受限于 GIL（全局解释器锁），无法实现真正的多核并行计算。

#### 适用场景

- 网络爬虫
- 文件下载/上传
- 等待外部资源的任务

#### 优缺点

- 优点：编程简单，适合 I/O 密集型任务。
- 缺点：受 GIL 限制，CPU 密集型任务加速有限；线程切换有开销，线程安全问题需注意。

#### 示例

```python
import threading

def task():
    print("任务执行中")

t = threading.Thread(target=task)
t.start()
t.join()
```

---

### 2.2 多进程（multiprocessing）

#### 原理

- 进程是资源分配的最小单位，每个进程有独立的内存空间。
- Python 的 `multiprocessing` 模块可以利用多核 CPU，实现真正的并行计算。
- 适合 CPU 密集型任务（如数据处理、科学计算）。

#### 适用场景

- 图像处理
- 大规模数据计算
- 机器学习模型训练

#### 优缺点

- 优点：可利用多核 CPU，适合 CPU 密集型任务；进程间互不影响，安全性高。
- 缺点：进程间通信复杂，资源消耗大，启动慢。

#### 示例

```python
from multiprocessing import Process

def task():
    print("进程任务执行中")

p = Process(target=task)
p.start()
p.join()
```

---

### 2.3 协程（coroutine）

#### 原理

- 协程是一种用户态的轻量级线程，由程序自身调度（非操作系统）。
- Python 3.5+ 提供了 `asyncio` 标准库和 `async/await` 语法，支持原生协程。
- 适合大量 I/O 密集型并发任务，极大减少线程/进程切换的开销。

#### 适用场景

- 高并发网络服务（如 Web 服务器、聊天服务器）
- 大规模异步爬虫
- 异步数据库操作

#### 优缺点

- 优点：极高的并发能力，资源消耗低，切换开销小。
- 缺点：只适合 I/O 密集型任务，代码风格与同步不同，调试较难。

#### 示例

```python
import asyncio

async def task():
    print("协程任务执行中")

asyncio.run(task())
```

---

### 2.4 对比总结

| 模型   | 适用场景 | 是否并行 | 资源消耗 | 编程难度 | 典型库          |
| ------ | -------- | -------- | -------- | -------- | --------------- |
| 多线程 | I/O 密集 | 否       | 低       | 低       | threading       |
| 多进程 | CPU 密集 | 是       | 高       | 中       | multiprocessing |
| 协程   | I/O 密集 | 否       | 极低     | 中       | asyncio         |

---

### 2.5 其他相关模型

- **事件驱动模型**：如 `asyncio`、`Twisted`，基于事件循环调度任务。
- **回调函数**：早期异步编程常用，易陷入“回调地狱”。
- **第三方库**：如 `gevent`（基于协程的并发库）、`concurrent.futures`（统一线程池/进程池接口）。

---

**小结**：  
Python 提供了多种异步编程模型，选择合适的模型需根据任务类型（I/O 密集 or CPU 密集）、并发量、资源消耗等因素综合考虑。现代异步编程推荐使用 `asyncio` 和 `async/await` 语法，既高效又易于维护。
